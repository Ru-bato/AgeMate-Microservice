"use strict";
Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
const fs = require("node:fs");
const configsByCategory = require("./generated/configs-by-category.cjs");
const JSONCParser = require("jsonc-parser");
const constants = require("./constants.cjs");
const allRulesObjects = Object.values(configsByCategory).map(
  (config) => config.rules
);
const allRules = allRulesObjects.flatMap(
  (rulesObject) => Object.keys(rulesObject)
);
const defaultPlugins = ["react", "unicorn", "typescript"];
const defaultCategories = { correctness: "warn" };
const isObject = (value) => typeof value === "object" && value !== null && !Array.isArray(value);
const getConfigContent = (oxlintConfigFile) => {
  try {
    const content = fs.readFileSync(oxlintConfigFile, "utf8");
    try {
      const configContent = JSONCParser.parse(content);
      if (!isObject(configContent)) {
        throw new TypeError("not an valid config file");
      }
      return configContent;
    } catch {
      console.error(
        `eslint-plugin-oxlint: could not parse oxlint config file: ${oxlintConfigFile}`
      );
      return void 0;
    }
  } catch {
    console.error(
      `eslint-plugin-oxlint: could not find oxlint config file: ${oxlintConfigFile}`
    );
    return void 0;
  }
};
const handleCategoriesScope = (plugins, categories, rules) => {
  for (const category in categories) {
    const configName = `flat/${category}`;
    if (categories[category] === "off" || !(configName in configsByCategory)) {
      continue;
    }
    const possibleRules = configsByCategory[configName].rules;
    for (const rule of Object.keys(possibleRules)) {
      for (const plugin of plugins) {
        const pluginPrefix = plugin in constants.aliasPluginNames ? constants.aliasPluginNames[plugin] : plugin;
        if (pluginPrefix === "" && !rule.includes("/")) {
          rules[rule] = "off";
        } else if (rule.startsWith(`${pluginPrefix}/`)) {
          rules[rule] = "off";
        }
      }
    }
  }
};
const getEsLintRuleName = (rule) => {
  if (!rule.includes("/")) {
    return allRules.find(
      (search) => search.endsWith(`/${rule}`) || search === rule
    );
  }
  const match = rule.match(/(^.*)\/(.*)/);
  if (match === null) {
    return void 0;
  }
  const pluginName = match[1];
  const ruleName = match[2];
  let esPluginName = pluginName in constants.aliasPluginNames ? constants.aliasPluginNames[pluginName] : pluginName;
  if (esPluginName === "react" && constants.reactHookRulesInsideReactScope.includes(ruleName)) {
    esPluginName = "react-hooks";
  }
  const expectedRule = esPluginName === "" ? ruleName : `${esPluginName}/${ruleName}`;
  return allRules.find((rule2) => rule2 == expectedRule);
};
const handleRulesScope = (oxlintRules, rules) => {
  for (const rule in oxlintRules) {
    const eslintName = getEsLintRuleName(rule);
    if (eslintName === void 0) {
      console.warn(
        `eslint-plugin-oxlint: could not find matching eslint rule for "${rule}"`
      );
      continue;
    }
    if (isActiveValue(oxlintRules[rule])) {
      rules[eslintName] = "off";
    } else if (rule in rules && isDeactivateValue(oxlintRules[rule])) {
      delete rules[eslintName];
    }
  }
};
const isValueInSet = (value, validSet) => validSet.includes(value) || Array.isArray(value) && validSet.includes(value[0]);
const isDeactivateValue = (value) => isValueInSet(value, ["off", 0]);
const isActiveValue = (value) => isValueInSet(value, ["error", "warn", 1, 2]);
const readPluginsFromConfig = (config) => {
  return "plugins" in config && Array.isArray(config.plugins) ? config.plugins : void 0;
};
const readCategoriesFromConfig = (config) => {
  return "categories" in config && isObject(config.categories) ? config.categories : void 0;
};
const readRulesFromConfig = (config) => {
  return "rules" in config && isObject(config.rules) ? config.rules : void 0;
};
const buildFromOxlintConfig = (config) => {
  const rules = {};
  const plugins = readPluginsFromConfig(config) ?? defaultPlugins;
  plugins.push("eslint");
  handleCategoriesScope(
    plugins,
    readCategoriesFromConfig(config) ?? defaultCategories,
    rules
  );
  const configRules = readRulesFromConfig(config);
  if (configRules !== void 0) {
    handleRulesScope(configRules, rules);
  }
  return [
    {
      name: "oxlint/from-oxlint-config",
      rules
    }
  ];
};
const buildFromOxlintConfigFile = (oxlintConfigFile) => {
  const config = getConfigContent(oxlintConfigFile);
  if (config === void 0) {
    return [
      {
        name: "oxlint/from-oxlint-config"
      }
    ];
  }
  return buildFromOxlintConfig(config);
};
exports.buildFromOxlintConfig = buildFromOxlintConfig;
exports.buildFromOxlintConfigFile = buildFromOxlintConfigFile;
